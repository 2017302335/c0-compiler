# 编译设计文档

## 一、需求说明
### 1. 文法说明

> ＜加法运算符＞ ::= +｜-
> 
> ＜乘法运算符＞  ::= *｜/
>
>＜关系运算符＞  ::=  <｜<=｜>｜>=｜!=｜==
>
>＜字母＞   ::= ＿｜a｜．．．｜z｜A｜．．．｜Z
>
>＜数字＞   ::= ０｜＜非零数字＞
>
>＜非零数字＞  ::= １｜．．．｜９
>
>＜字符＞    ::=  '＜加法运算符＞'｜'＜乘法运算符＞'｜'＜字母＞'｜'＜数字＞'
>
>＜字符串＞   ::=  "｛十进制编码为32,33,35-126的ASCII字符｝"
>
>＜程序＞    ::= ［＜常量说明＞］［＜变量说明＞］{＜有返回值函数定义＞|＜无返回值函数定义＞}＜主函数＞
>
>＜常量说明＞ ::=  const＜常量定义＞;{ const＜常量定义＞;}
>
>＜常量定义＞   ::=   int＜标识符＞＝＜整数＞{,＜标识符＞＝＜整数＞} | char＜标识符＞＝＜字符＞{,＜标识符＞＝＜字符＞}
>
>＜无符号整数＞  ::= ＜非零数字＞｛＜数字＞｝
>
>＜整数＞        ::= ［＋｜－］＜无符号整数＞｜０
>
>＜标识符＞    ::=  ＜字母＞｛＜字母＞｜＜数字＞｝
>
>＜声明头部＞   ::=  int＜标识符＞ |char＜标识符＞
>
>＜变量说明＞  ::= ＜变量定义＞;{＜变量定义＞;}
>
>＜变量定义＞  ::= ＜类型标识符＞(＜标识符＞|＜标识符＞‘[’＜无符号整数＞‘]’){,(＜标识符＞|＜标识符＞‘[’＜无符号整数＞‘]’ )}
>
>＜常量＞   ::=  ＜整数＞|＜字符＞
>
>＜类型标识符＞      ::=  int | char
>
>＜有返回值函数定义＞  ::=  ＜声明头部＞‘(’＜参数＞‘)’ ‘{’＜复合语句＞‘}’|＜声明头部＞‘{’＜复合语句＞‘}’  //第一种选择为有参数的情况，第二种选择为无参数的情况
>
>＜无返回值函数定义＞  ::= void＜标识符＞(’＜参数＞‘)’‘{’＜复合语句＞‘}’| void＜标识符＞{’＜复合语句＞‘}’//第一种选择为有参数的情况，第二种选择为无参数的情况
>
>＜复合语句＞   ::=  ［＜常量说明＞］［＜变量说明＞］＜语句列＞
>
>＜参数＞    ::= ＜参数表＞
>
>＜参数表＞    ::=  ＜类型标识符＞＜标识符＞{,＜类型标识符＞＜标识符＞}
>
>＜主函数＞    ::= void main‘(’‘)’‘{’＜复合语句＞‘}’
>
>＜表达式＞    ::= ［＋｜－］＜项＞{＜加法运算符＞＜项＞}
>
>＜项＞     ::= ＜因子＞{＜乘法运算符＞＜因子＞}
>
>＜因子＞    ::= ＜标识符＞｜＜标识符＞‘[’＜表达式＞‘]’|‘(’＜表达式＞‘)’｜＜整数＞|＜字符＞｜＜有返回值函数调用语句＞         
>
>＜语句＞    ::= ＜条件语句＞｜＜循环语句＞| ‘{’＜语句列＞‘}’｜＜有返回值函数调用语句＞; |＜无返回值函数调用语句＞;｜＜赋值语句＞;｜＜读语句＞;｜＜写语句＞;｜＜空＞;|＜情况语句＞｜＜返回语句＞;
>
>＜赋值语句＞   ::=  ＜标识符＞＝＜表达式＞|＜标识符＞‘[’＜表达式＞‘]’=＜表达式＞
>
>＜条件语句＞::= if ‘(’＜条件＞‘)’＜语句＞else＜语句＞
>
>＜条件＞    ::=  ＜表达式＞＜关系运算符＞＜表达式＞｜＜表达式＞ //表达式为0条件为假，否则为真
>
>＜循环语句＞   ::=  while ‘(’＜条件＞‘)’＜语句＞
>
>＜情况语句＞  ::=  switch ‘(’＜表达式＞‘)’ ‘{’＜情况表＞[＜缺省＞] ‘}’
>
>＜情况表＞   ::=  ＜情况子语句＞{＜情况子语句＞}
>
>＜情况子语句＞  ::=  case＜常量＞：＜语句＞
>
>＜缺省＞   ::=  default : ＜语句＞
>
>＜有返回值函数调用语句＞ ::= ＜标识符＞‘(’＜值参数表＞‘)’|<标识符//第一种选择为有参数的情况，第二种选择为无参数的情况
>
>＜无返回值函数调用语句＞ ::= ＜标识符＞‘(’＜值参数表＞‘)’|<标识符//第一种选择为有参数的情况，第二种选择为无参数的情况
>
>＜值参数表＞   ::= ＜表达式＞{,＜表达式＞}
>
>＜语句列＞   ::= ｛＜语句＞｝
>
>＜读语句＞    ::=  scanf ‘(’＜标识符＞{,＜标识符＞}‘)’
>
>＜写语句＞    ::= printf ‘(’ ＜字符串＞,＜表达式＞ ‘)’| printf ‘(’＜字符串＞ ‘)’| printf ‘(’＜表达式＞‘)’
>
>＜返回语句＞   ::=  return[‘(’＜表达式＞‘)’]     

**附加说明：**

（1）char类型的表达式，用字符的ASCII码对应的整数参加运算，在写语句中输出字符

（2）标识符不区分大小写字母

（3）写语句中的字符串原样输出 

（4）情况语句中，switch后面的表达式和case后面的常量只允许出现int和char类型；每个情况子语句执行完毕后，不继续执行后面的情况子语句 

（5）数组的下标从0开始

### 2. 目标代码声明

生成MIPS代码，包含伪指令。

### 3. 优化方案

#### 3.1 常数合并

对表达式中出现的常数计算进行合并，于C0代码生成中间代码优化

优化前：b = 3 + 5 + a

优化后：b = 8 + a

#### 3.2 基本块内部的公共子表达式删除

对中间代码中的公共子表达式进行局部删减，生成新的中间代码

优化前：

\#0 = a + b

x = a + \#0

\#1 = a + b

y = a + \#1

优化后：

\#0 = a + b

x = a + \#0

y = x

#### 3.3 复制传播

摘自新版教材352页：

>如果在代码中有形如x=y的变量复制语句，在不影响程序正确性的前提下，在此后的语句中，尽可能用y来代替x。

#### 3.4 基本块内数据流分析

3.2, 3.3中的操作可能导致部分临时变量被赋值但没有被使用，此时通过**基本块内定义-使用分析**，去除这部分赋值语句

#### 3.5 基本块间数据流分析

分析不同基本块之间的**定义-使用**情况，得到每个基本块的use、def、in、out、live集合

#### 3.6 全局寄存器分配

通过3.5中得到的**定义-使用链**，利用**染色法**分配全局寄存器

#### 3.7 临时寄存器分配

根据3.4中的结果，为临时变量分配寄存器

#### 3.8 寄存器调度优化

对于未分配寄存器的变量，采用**“最久不用”**替换策略进行寄存器的替换

#### 3.9 跳转优化与死代码删除

对于一些永远为true或false的条件判断，如“0<1”，此时无需进行branch的判断，可以直接使用j语句或省略分支跳转语句。对于永远无法达到的代码需要进行死代码删除。

## 二、详细设计
### 1. 程序结构
![](http://images2017.cnblogs.com/blog/1254668/201801/1254668-20180113204724363-1222057230.png)

### 2. 类\方法\函数功能
#### 2.1 错误处理

    void error(string info); // 输出错误信息

#### 2.2 词法分析

    bool next_end(); // 判断是否读完文件
    bool readchar(); // 从文件内读入一个字符，返回true表示成功读入，返回false表示读到文件末尾
    void retract(); // 回退一个字符
    bool getsym(); // 获取一个符号，返回true表示成功获取，返回false表示获取失败

#### 2.3 符号表管理
**类：**

    class Item; // 符号表
    class VarItem; // Item子类，变量符号表
    class ConstItem; // Item子类，常量符号表
    class FuncItem; // Item子类，函数符号表

**方法：**

    int VarItem::get_len(); // 获取元素个数，非数组变量返回0
    bool VarItem::isarray(); // 判断是否为数组
    void FuncItem::put_para(string name, Type type); // 向函数符号表中添加参数
    void FuncItem::put_const(string name, Type type, int value); // 向函数符号表中添加常量
    void FuncItem::put_var(string name, Type type, int len); // 向函数符号表中添加变量
    ConstItem* FuncItem::get_const(string name); // 根据常量名name获取常量符号表信息
    VarItem* FuncItem::get_var(string name); // 根据变量名name获取变量符号表信息
    bool FuncItem::has_const(string name); // 判断是否有常量name
    bool FuncItem::has_var(string name); // 判断是否有变量name
    bool FuncItem::para_check(vector<Type> types); // 判断参数类型是否相符
    bool FuncItem::get_para_count(); // 获取参数个数

**函数：**

    VarItem\* get_global_var(string name); // 获取全局变量name的符号表信息
    ConstItem\* get_global_const(string name); // 获取全局常量name的符号表信息
    FuncItem\* get_func(string name); // 获取函数name的符号表信息
    Item\* get_item(string name); // 获取对应的（全局/局部）（变量/常量）或函数的符号表信息
    void put_global_const(string name, Type type, int value); // 存入全局常量
    void put_global_var(string name, Type type, int len); // 存入全局变量

#### 2.4 语法分析

    void getsym_check(); // 判断程序是否完整
    void skip(Symbol); // 跳读至指定符号
    void record_name(); // 记录变量\函数\常量名等
    void mate(Symbol sym, void (*handle_ptr)(), Symbol skip_sym); // 符号匹配，并执行传入的函数处理该符号，若不匹配，则根据传入的skip_sym进行跳读
    Type expr(int* value, bool* certain, string* name); // 读入一个由“+ / -”连接的表达式，若certain为true，表示该表达式的值是确定的常数，该值为value，否则返回接收表达式的变量 
    Type item(int* value, bool* certain, string* name); // 读入一个由“* / /”连接的表达式，参数意义同上
    Type factor(int* value, bool* certain, string* name); // 读入一个因子，可以是常数、变量、常量、有返回值的函数或表达式，参数意义同上
    void cond(int* value, bool* certain, string* name); // 读入条件式，并将条件的判断结果转变成变量的形式，参数意义同上
    Item* read_ident(string* index_name); // 读取并分析标识符，若为数组，通过index_name传回接收下标的变量名，返回对应的符号表信息
    void statement(); // 读入一条语句
    bool defined(string name); // 判断name是否被定义过
    void declare_const(FuncItem* func); // 读入定义常量部分，func表示所属函数，为NULL表示为全局常量
    void declare_var(FuncItem* func); // 读入定义变量部分，func表示所属函数，为NULL表示为全局变量
    void comp_statement(FuncItem* func); // 读入语句块，func为
    void declare_func(); // 读入定义函数部分

#### 2.5 DAG图消除公共子表达式优化
**主要算法：**

 - 通过构造DAG图表示各个变量之间的依赖关系，同时构造结点表，用来记录变量名对应的结点，大体算法和教材上介绍类似。此外还进行了一些修改，如：
    - 扩大了基本块的范围，允许基本块中出现分支、调用函数语句等
    - 每个结点都有一个bool型变量certain表示该结点的值是否已被确定，其中叶子结点的值初始就为确定状态。如果结点的certain为true，就表示该结点所代表的变量可以直接使用，否则需要向下遍历，根据其子结点输出新的中间代码并将certain置为true。
    - 只在必要的时候将DAG图中部分内容输出，如在调用函数之前输出全部全局变量相关语句，在printf之前输出其后变量相关语句等等，并在基本块末尾将全部变量相关语句输出。

**类：**

    class Node; // DAG图结点
    
**方法：**

    void Node::make_certain(); // 通过输出语句使结点确定化

**函数：**

    void init_DAG(); // 初始化DAG
    void remove_var(string name); // 将name从结点表中移除
    map<string, Node*>::iterator export_code(map<string, Node*>::iterator it); // 以该结点为父结点输出DAG图语句
    map<string, Node*>::iterator record_code(map<string, Node*>::iterator it); // 记录结点
    void refresh_global_vars(); // 输出所有全局变量语句
    void refresh_vars(); // 输出所有变量语句
    void has_node(string name); // 判断name是否在结点表中
    void set_node(string name, Node* nodeptr); // 给name赋予新的结点
    Node* get_node(string name); // 获取name的结点，如果没有，就创建一个
    void set_name(Node* node); // 更新node结点的name
    string get_name(Node* node); // 获取node结点的name
    void build_DAG(vector<string> code); // 将指令添加至DAG图中
    string use_new_name(string name); // 获取原中间代码中name对应的新名字
    void read_medis(); // 读中间代码

#### 2.6 复制传播与局部数据流分析
**主要算法：**

 - 扫描基本块，对每一行中间代码建立一个Line，并将中间代码存储至仓库中。如果该行为非数组操作的赋值语句，那么将Line的active置为false，否则置为true
 - 若一个变量被赋值了，做以下操作：
     - 如果变量有对应的Block，且last_used_line不为-1，则将该变量的变量名存入last_used_line对应的Line中；如果没有对应的Block，新建一个。
     - 将当前行号作为def_line存入Block中，并将last_used_line设为-1
     - 断开该Block和其它Block之间的nature关系
     - 如果为一对一的赋值语句，将nature指向等号右边的Block（如果没有，新建一个）
 - 如果一个变量被用到了，做以下操作
    - 如果有对应的Block，将def_line对应的Line的active值置为true，并将该行行号更新至Block的last_used_line中，返回nature链最末端的name
    - 如果没有对应的Block，无需新建，直接返回原名字
 - 如果赋值语句满足一定条件（如乘法指令中某乘数为0，或为常数计算式等等），将其计算为常数赋值语句

**类：**

    class Line; // 代码行信息
    class Block; // 变量信息块

**方法：**

    Block* Block::get_nature(); // 获取实质信息块

**函数：**

    bool has_line(int line); // 判断该行是否被存储
    void save_used_to_line(Block* useblock); // 将变量名更新至最后使用的代码行
    bool has_block(string name); // 判断name是否存储于block_map中
    string def(int line, string defname, string usename = ""); // 定义一个变量，line为行号，defname是被定义的变量的名字，usename是赋值语句中等号右侧的名字
    string use(string usename); // 使用一个变量
    void store_medi(vector<string> code); // 将中间代码存储至临时仓库中
    void init_blocks(); // 初始化
    string get_new_temp(string tempname); // 获取新的temp值
    void remove_temp(string tempname); // 将tempname对应的新temp值存储至temp池中，并将键值对从temp_map中移除
    void save_vars(); // 将所有变量标记为被使用过
    void snatch_new_temp(string oldtemp, string newtemp); // 将newtemp强制设为oldtemp对应的新temp
    bool is_last_use(string oldname, int lineno); // 判断oldname是否在lineno行中最后一次使用
    void set_last_use_before_output(bool is_return); // 在输出之前将所有block记录至对应的最后一次使用的行号对应的Line中
    void output_medis(bool is_return = false); // 输出临时仓库中的中间代码并做局部替换
    void expre_opt(vector<string>* strs); // 如果是常数计算式，直接将strs修改为常数赋值语句
    void ass_read_medis(); // 读取中间代码

#### 2.7 活跃变量分析
**主要算法：**

 - 参考书上算法，利用定义-使用链与图着色算法分配全局寄存器，对书上的冲突定义做了一些更改，书上只对入口处同时活跃的变量才看做冲突，个人认为应当同时考虑入口处和出口处，因此建立了一个out和in的并集live，作为冲突的依据
 - 对每一个函数：
    1. 构造基本块图（前驱、后继），求出每个基本块的use、def字符串集合，同时记录基本块顺序
    2. 逆序遍历基本块，计算出每个基本块的in、out，此时将字符串封装为Var_node，以区分分配不同寄存器的同一变量
    3. 重复2步骤，当向集合添加元素的时候，置changed为true，直到changed为false为止
    4. 将所有变量都扔到一个set中，并初始化一个栈，将各个当前冲突个数初始化为冲突集合的长度，按照图着色算法分配寄存器
    5. 根据结果转化成变量名-寄存器map，按照函数名分别存储

**类：**

    class Code_block; // 基本块

**方法：**

    void Code_block::try_use(string name); // 尝试将name分入use集合中
    void Code_block::try_def(string name); // 尝试将name分入def集合中
    bool Code_block::refresh_out(); // 更新block的out集合
    void Code_block::refresh_in(); // 更新block的in集合

**函数：**

    int get_regno(string funcname, string cblockname, string varname); // 根据函数名和基本块名获取varname的寄存器编号
    bool is_local_var(string funcname, string cblockname, string varname); // 判断是否为局部活跃变量
    void finish_function_in_out(); // 更新in和out集合直到结果不再改变
    void complete_set_varnodes(set<Var_node*>* dustbin, Code_block* cblock, VARNODE_MAP* vnmap); // 合并in和out至lives，同时将同名的其它block放入dustbin中
    void complete_function_varnodes(); // 完成函数内每一个基本块的分析，将无用Varnode删除
    bool has_code_block(string label); // 判读是否有label对应的code_block
    string set_temp_label(); // 建立一个虚拟标签
    Code_block* get_code_block(string label); // 根据label获取code_block 
    void link_code_blocks(Code_block* prev, Code_block* next); // 链接两个基本块
    void turn_next_block(string label); // 将label对应的基本块设为当前基本块
    void livevar_read_medis(); // 读取中间代码

#### 2.8 染色法分配寄存器
**类：**

    class Var_node; // 变量数据结点

**方法：**

    Var_node* Var_node::get_terminal_ptr(); // 获取同名结点链的末端结点
    void Var_node::set_regno(int reg_max); // 根据冲突情况获取寄存器
    void Var_node::cut_conflicts(); // 与冲突结点断开连接

**函数：**

    void refresh_conflict(Code_block* cblock); // 更新基本块内的变量冲突情况
    void init_conflict_count(); // 将冲突个数初始化为冲突集合大小
    void push_vnode_stack(set<Var_node*>::iterator it); // 将变量推入栈中
    bool repush_stack(int reg_max); // 尽可能多地将变量推入栈中
    void select_vnode_without_reg(); // 选出一个不分配全局寄存器的变量
    void graph_to_stack(int reg_max); // 将冲突图中的变量按照染色法的规则推入栈中
    void stack_reg_distri(int reg_max); // 向栈中的变量分配寄存器
    void reg_distri(int reg_max); // 完成一个函数的寄存器分配
    void complete_function(); // 完成对一个函数的分析
    void clear_graph(); // 清空冲突图
    void init_graph(string funcname); // 初始化冲突图 

#### 2.9 分支跳转优化

    bool try_store_conf(vector<string> conf_strs); // 将比较运算转化成分支跳转语句头，并存入语句堆中
    void output_heap(bool skip); // 将堆中的语句输出
    void brjp_read_medis(); // 读取中间代码

#### 2.10 输出目标代码
**主要算法：**

 - 涉及的寄存器为：$s0~$s7, $t0~$t9
 - 每个寄存器有三种状态：OCCUPIED、MODIFIED、INACTIVE：
     - INACTIVE表示其值没有被更改过，可以直接被新的值覆盖而无需再将寄存器的值存储回内存中
     - MODIFIED表示其值被修改过，被其它变量使用的时候需要将寄存器的值写回内存
     - OCCUPIED表示该寄存器被占领，不能被其它变量使用
 - 有两种情况可以导致寄存器进入OCCUPIED状态：
     - 对于$s寄存器，假如该寄存器在图着色算法中被分配给了变量，则当变量占领该寄存器的时候，置为OCCUPIED
     - 对于$t寄存器，假如占领该寄存器的为临时号小于8的临时变量（#0~#7），则当该变量占领该寄存器的时候，置为OCCUPIED
 - 对于其余变量，利用“最久不用”替换策略占领除OCCUPIED状态以外的寄存器 
 - 寄存器初始化策略：
     - 标签之前：存储除局部活跃变量以外的MODIFIED，初始化全部寄存器
     - 分支跳转之前：存储除局部活跃变量以外的MODIFIED，初始化变量（$s）OCCUPIED，初始化局部活跃变量MODIFIED
     - return之前：存储全局变量的MODIFIED，初始化全部寄存器
     - 函数调用之前：OCCUPIED进栈，存储MODIFIED，初始化全部寄存器
     - 函数调用之后：OCCUPIED出栈

**类：**

    class Reg_recorder; // 寄存器记录

**方法：**

    void Reg_recorder::clear_and_init(); // 如果寄存器处于MODIFIED状态，将结果更新至内存，并初始化
    void Reg_recorder::init(); // 初始化
    void Reg_recorder::save(); // 如果寄存器处于MODIFIED状态，将结果更新至内存
    void Reg_recorder::load(); // 从内存中取值
    static void record_occu_regs(list<string>* save_list);; // 将OCCUPIED状态寄存器记录
    static void save_occu_regs(list<string>* save_list, int offset);; // 将OCCUPIED状态寄存器保存至栈中
    static void load_occu_regs(list<string>* save_list, int offset);; // 将OCCUPIED寄存器从栈中取出
    static void save_modi_regs();; // 将MODIFIED状态寄存器保存至内存中
    static void clear_and_init_all();; // 将所有寄存器结果更新至内存并初始化
    static void init_var_occu_regs();; // 初始化处于OCCUPIED状态且内容为变量的寄存器
    static void init_all();; // 初始化全部寄存器
    static void save_global_modi_regs();; // 将处于MODIFIED状态且内容为全局变量的寄存器保存至内存中
    static void before_branch_jump();; // 在分支跳转语句之前进行寄存器更新操作
    static void before_label();; // 在标签之前进行寄存器更新操作
    static void before_return();; // 在return之前更新寄存器更新操作
    static void local_modi_regs(void(Reg_recorder::*func)(), bool not_reverse); // 对单基本块活跃变量进行func操作，可以通过not_reverse选项控制是否反选

**函数：**

    void init_global_regs(); // 初始化全局寄存器 
    void init_reg_map(); // 初始化寄存器map
    void init_func(string funcname); // 初始化函数信息
    void init_var(VarItem* var_item); // 初始化变量或参数信息（如偏移量计算等）
    void assign_para_tar(string paraname); // 赋值语句输出目标代码
    Reg_recorder* get_min_use_recorder(); // 获取最近不用且不处于OCCUPIED状态的寄存器
    string get_reg(string name, bool is_def); // 为name分配寄存器，is_def表示是否在等号左侧
    void output_shift_mul_div(string op, string tar, string str_cal, int num_cal); // 以偏移形式输出乘除法目标代码
    void cal_tar(string op, string tar_str, string cal_str1, string cal_str2); // 输出计算式的目标代码
    VarItem* get_var_item(string name); // 获取变量在当前函数中的符号表信息
    int get_var_offset(string name); // 获取变量在内存中存储的偏移量
    void array_tar(string arr_str, string off_str, string sou_str, bool is_set); // 输出数组操作的目标代码
    void name_handle(vector<string> strs); // 处理标签、赋值与计算语句
    void call_tar(string funcname); // 输出调用函数的目标代码
    void readline(); // 读取中间代码
    void set_data_str(); // 输出data端处理目标代码

### 3. 调用依赖关系

![](http://images2017.cnblogs.com/blog/1254668/201801/1254668-20180113204729019-526011799.png)


### 4. 符号表管理方案
![](http://images2017.cnblogs.com/blog/1254668/201801/1254668-20180113204727738-648045165.png)
#### 4.1 数据结构
 - 如图，由于本次文法中不支持函数嵌套，因此没有采用栈式符号表，而是建立了三个Map，分别存储**全局变量信息地址**、**全局常量信息地址**和**函数信息地址**。
 - 函数信息中包含两个Map和一个数组，两个Map中分别存储**局部变量信息地址**和**局部常量信息地址**，数组中按传递顺序存储**局部变量信息地址**。其中，参数数组中的内容同样被包含在变量Map之中，区别只在于存储方式的不同。
 - 函数信息中的大小（灰色部分）实际没有被用到。

#### 4.2 相关算法

 - 在向表中存储数据的时候需要判断该名称是否已被定义，此时先遍历一遍**函数信息表**，再遍历一遍当前函数信息内的**局部变量信息表**和**局部常量信息表**，如果没有出现用名相同的情况，则是合法名称。
 - 在通过变量（常量）名获取信息的时候，需要先遍历当前函数信息内的**局部变量信息表**和**局部常量信息表**，如果找到，说明该变量（常量）为局部变量（常量），否则再遍历**全局变量信息表**和**全局常量信息表**。

### 5. 存储分配方案
![](http://images2017.cnblogs.com/blog/1254668/201801/1254668-20180113204731019-1745518736.png)

 - 如图，其中常量部分在编译中已经被转变为常数了，因此不必存储
 - \$gp指向全局数据区的数据底部，\$fp指向当前函数变量区的数据底部，\$sp为栈指针，栈指针以上存储前面函数中需要保存的寄存器
     
### 6. 解释执行程序
（难度3不要求解释执行程序）

### 7. 四元式设计
0. 临时变量：#x, x=0,1,2...
1. 函数声明
	@func foo // 声明函数foo
	@para a // 定义foo的参数a
2. 函数调用
	@push x // 传入参数x
	@call tar // 调用char类型函数tar
	@get i // 接收返回值
3. 函数返回
	@ret x 	// 将x返回
    @ret	// 什么也不返回
4. 变量声明
	@var int i // 声明变量i
    @var int[] a 100
5. 常数声明
	中间代码无常数
6. 表达式
	\#1 = b ADD c	// 加法
    \#2 = b SUB c	// 减法
	\#3 = a MUL #1	// 乘法
    \#4 = a DIV #1	// 除法
    \#5 = a GE b	// 若a>=b，t5置1，否则置0
	x = #2
8. 条件或无条件跳转
@j LABEL1 // 无条件跳转到LABEL1
@be x y LABEL1 // x==y则跳转到LABEL1
@bz x LABEL1 // x==0则跳转到LABEL1
@bltz x LABEL1 // x<0则跳转到LABEL1
9. 带标号语句
	Label_1 : // 标号
	x = a + b // 语句
10. 数组赋值或取值
	\#1 = a ARGET b	// 将a[b]赋值给1号临时变量
    a  = b ARSET #2	// 将2号临时变量赋值给a[b]
11. 输出
    @printf string 123
    @printf int b
12. 输入
    @scanf int a
13. 退出
    @exit
14. 虚拟标签（数据流分析添加）
    @label 0 // 一个标签名为0的虚拟标签
15. 释放寄存器
    @free #1 // 在free下面的语句执行完毕后可以释放#1的寄存器

### 8. 目标代码生成方案
 - 采用图着色分配全局寄存器，为临时变量#0~#7直接分配寄存器，采用“最久不用”策略为其它变量分配余下的寄存器
 - 具体算法见2.6、2.7、2.10
 
### 9. 优化方案
#### 9.1 常数合并（于语法分析优化）
 - 采用expr、item、factor三个函数的相互递归实现表达式的读取
 - 每个函数都有三个参数：int\* value, bool\* certain, string\* name。这三个参数都相当于返回值，certain表示读取该式子之后是否可以直接得到常数结果，如果是，那么常数结果会通过value返回。因为临时变量的申请是在这三个函数中进行的，因此必须通过name将申请的临时变量名返回至函数外部，name与常数合并无关
 - 当读取符号时，会先默认certain为true，之后只要读到数字，就会将数字与现有数字进行计算，但一旦读到了标识符，就会将certain置为false，并输出一条标识符和现有数字进行计算的中间代码

#### 9.2 基本块内部的公共子表达式删除
 - 主要是构造了DAG图，本质是一个树形结构，其余还有STL的Map
 - 具体算法见2.5

#### 9.3 复制传播
 - Block的nature指针形成了链表的结构，其余还有STL的Map
 - 具体算法见2.6

#### 9.4 基本块内数据流分析
 - 同9.3

#### 9.5 基本块间数据流分析
 - 不同的基本块之间存在着前驱和后继的关系，每个基本块可能存在多个后继和多个前驱，因此构成一张基本表的前驱后继图
 - 基本块的use、def集合存储的是变量的字符串，而in、out存储的是Var_node的指针，因为可能存在同一名称的变量可以分配不同寄存器的情况，用Var_node来表示就可以区分出可以分配不同寄存器的同一变量
 - 每个基本块的变量在一开始都会申请一个Var_node，这样可能会出现本质上相同的变量却有了不同的Var_node的情况，因此必须进程结点的合并。以更新out集合的过程为例，此时会将所有后继基本块的in集合合并到现基本块的out集合内：
     - 结点中包含一种末端结点指针，指向同名的、本质相同的其它结点，在与其它结点的比较中以末端结点代替自己，从而达到结点合并的目的
     - 依次遍历所有的in集合，如果某结点表示的变量未出现在out集合中时，将该结点指针之间存入out集合中
     - 如果某结点表示的变量出现在out集合中，且其末端结点指针与out集合中对应结点的末端指针不同，此时将out中对应结点的末端结点加入该结点的链表中，即将out中对应结点的末端结点作为该结点的末端结点
     - 重复刷新out和in集合，直到不发生变动，为末端结点相同的结点为分配同一寄存器
 - 其余算法见2.7

#### 9.6 全局寄存器分配
 - 构造了Var_node的图
 - 具体算法见2.7

#### 9.7 临时寄存器分配
 - 根据3.4中的结果，将临时变量#0~#7直接分配至$t0~$t7

#### 9.8 寄存器调度优化
 - 对于未分配寄存器的变量，采用**“最久不用”**替换策略进行寄存器的替换

#### 9.9 跳转优化与死代码删除
 - 对于一些永远为true或false的条件判断，如“0<1”，此时无需进行branch的判断，可以直接使用j语句或省略分支跳转语句。对于永远无法达到的代码需要进行死代码删除。
 
### 10. 出错处理
#### 10.1 词法阶段
**前置0**

错误信息：unexpected leading zero

处理：无视

**空字符**

错误信息：empty char

处理：无视

**非法字符**

错误信息：invalid char

处理：无视


**单引号内有多个字符**

错误信息：multiple chars

处理：一直读到出现另一个单引号


**字符串中出现非法字符**

错误信息：invalid char in string

处理：跳过该字符

**读到了未预料的符号**

错误信息：unexpected token '[字符]'

处理：跳过该符号，读下一个符号

#### 10.2 语法阶段
**源代码不完整**

错误信息：unfinished program

处理：结束程序

**符号类型不匹配**

错误信息：got [实际的符号类型] expected [期望的符号类型]

处理：当做已经匹配了

**除数为0**

错误信息：division by zero

处理：当做除数为1

**未知的标识符**

错误信息：unexpected token '[字符串]'

处理：结束当前语句

**使用数组没有指明下标**

错误信息：array '[数组名]' without an index

处理：无视


**非数组变量后跟[**

错误信息：[变量名] is not an array type

处理：无视，跳读至']'

**下标越界**

错误信息：index of array [数组名] out of range

处理：设下标为0

**函数传参不符**

错误信息：parameters to function '[函数名]' do not match

处理：无视

**将无返回值函数放入表达式内**

错误信息：void value not ignored as it ought to be

处理：假设读到的是0

**读到了未预料的计算因子**

错误信息：unexpected token '[名字]' in factor

处理：假设读到的是0

**类型不符**

错误信息：expected type '[预计类型]', got '[实际类型]'

处理：无视

**读到了未预料的case值**

错误信息：unexpected token '[字符串]' after case

处理：无视

**出现了相同的case分支**

错误信息：the case has been defined above

处理：无视

**有返回值函数中return语句没有返回值**

错误信息：return-statement with no value, in function returning '[返回类型]'

处理：无视

**scanf语句中出现了未预料的字符**

错误信息：unexpected token '[字符串]' in scanf

处理：无视

**scanf语句中出现了数组**

错误信息：can only write to variables

处理：无视

**单独的常量（变量）语句**

错误信息：meaningless [类型] '[常量（变量名）]'

处理：无视

**为非变量标识符赋值**

错误信息：assignment of non-var '[字符串]'

处理：跳读至分号

**不能将int赋值给char**

错误信息：cannot convert 'int' to 'char'

处理：无视

**未预料到的语句开头**

错误信息：unexpected token '[字符串]' in the beginning of the statement

处理：跳过

**重定义**

错误信息：redefinition of '[名称]'

处理：无视

**非法的常量类型**

错误信息：invalid const type [类型]

处理：跳读至分号

**有返回值函数没有返回**

错误信息：function returning '[类型]' without a return-statement

处理：无视

**main函数后还有内容**

错误信息：something behind 'main'

处理：无视

**没有main函数**

错误信息：undefined reference 'main'

处理：无视

**非法的返回值类型**

错误信息：invalid returning type []

处理：匹配下一个

**非法的参数类型**

错误信息：invalid parameter type []

处理：匹配下一个

## 三、操作说明
### 1. 运行环境
 - Windows Code::Block 13.12 C++
 
### 2, 操作步骤
 - 运行后输入源代码所在路径
 
## 四、测试报告
### 1. 测试程序及测试结果
#### 1.1 测试程序1（正确）
**程序**

    int g_ar_a;
	int g_ar_b;
	int g_ar_c;
	int g_ar_d;
	int g_ar_e;
	int g_ar_f;
	int g_ar_g;
	int g_ar_h;
	int g_ar_i;
	int g_ar_j;
	int g_a[2];
	int g_b[2];
	int g_c[2];
	int g_d[2];
	int g_e[2];

	int foo0(int para_a, int para_b, int para_c, int para_d, int para_e, int para_f, int para_g, int para_h, int para_i, int para_j)
	{
	int ar_a;
	int ar_b;
	int ar_c;
	int ar_d;
	int ar_e;
	int ar_f;
	int ar_g;
	int ar_h;
	int ar_i;
	int ar_j;
	int a[2];
	int b[2];
	int c[2];
	int d[2];
	int e[2];
	ar_a = 1;
	ar_b = 2;
	ar_c = 3;
	ar_d = -5;
	ar_e = 1;
	ar_f = -3;
	ar_g = -1;
	ar_h = 0;
	ar_i = -5;
	ar_j = 2;
	a[0] = 3;
	a[1] = 1;
	b[0] = 0;
	b[1] = 2;
	c[0] = 2;
	c[1] = -1;
	d[0] = 1;
	d[1] = -4;
	e[0] = 3;
	e[1] = -4;

	{
	ar_i = (ar_d);
	printf(" ",((ar_b)));
	e[1] = (0 + b[0]);
	g_b[0] = (g_e[1] + ar_d);
	printf(" ",(2));
	g_a[1] = (-5);
	if ((g_d[1]) > (ar_g + g_d[1] * d[1]))
	{
	}
	else
	{
	}
	ar_c = (g_ar_h + b[1] + para_e + -5 * -4);
	b[1] = (ar_h);
	g_ar_e = (-1);
	ar_h = (g_a[0]);
	e[0] = (-1 + a[0] * para_f + para_j);
	a[1] = (g_ar_b);
	if ((e[1]) <= (a[1]))
	{
	}
	else
	{
	}
	g_c[1] = (d[0]);
	if ((e[1]) != (b[1] * 2 * -3 + -2 - g_ar_h + ar_d - ar_g - ar_c))
	{
	}
	else
	{
	}
	if ((ar_d) != (1))
	{
	}
	else
	{
	}
	para_b = (g_ar_j - ar_g);
	c[0] = (a[0] * ar_f);
	if ((g_c[0] * para_d - (((para_c + g_ar_c)) - g_d[0] * 2 * (ar_i * 2)) * b[1]) <= (para_j))
	{
	}
	else
	{
	}
	para_h = (g_ar_j * 2);
	g_e[1] = (g_d[0]);
	if ((ar_d * (-5) - d[0] - -4 * a[1]) == (g_a[0]))
	{
	}
	else
	{
	}
	if ((ar_d + 4 + g_c[1]) > (g_ar_g))
	{
	}
	else
	{
	}
	e[1] = (para_i - 4 + (-4 * d[0] + g_b[0]) + 4 * ar_e + (ar_j));
	g_ar_i = ((g_ar_c - para_i - (ar_h)) * e[1]);
	if ((ar_b - g_ar_j + ar_e + g_d[0] * g_ar_j) >= (ar_j * (g_ar_e * g_e[0])))
	{
	}
	else
	{
	}
	g_ar_h = ((ar_d) - (3) - para_c * g_b[1] - para_j);
	ar_e = (g_c[1]);
	e[1] = (1);
	printf(" ",(-4 - g_b[0] + g_b[1]));
	g_d[1] = (g_b[1] + ar_a - 1 * ar_e + g_a[1]);
	a[0] = (ar_h);
	printf(" ",(g_ar_e - 3));
	if ((g_d[1] + c[1]) > (c[1] + para_d + c[1]))
	{
	}
	else
	{
	}
	g_c[0] = (g_d[1] - g_c[0] - 4);
	g_a[1] = (-3 - g_ar_i + -4);
	d[0] = (ar_a);
	printf(" ",(-4 - -5 - -4));
	e[0] = (g_ar_h);
	ar_h = (ar_i - para_c);
	ar_i = (g_c[0] - g_a[1]);
	g_d[0] = ((a[1]) + -5 - -4 + para_b * c[1]);
	g_ar_f = (g_e[1]);
	g_a[1] = (g_a[1] * ar_a);
	printf(" ",(1));
	g_ar_f = (g_e[1]);
	g_d[1] = (c[0]);
	if (((g_ar_h)) <= (g_a[0]))
	{
	}
	else
	{
	}
	g_c[1] = (g_c[1]);
	if (((4 * e[0])) != (-2 - g_ar_f - ar_i))
	{
	}
	else
	{
	}
	if ((a[0] + -4 + g_b[0] - g_a[0] + para_c - g_d[0]) != (c[0]))
	{
	}
	else
	{
	}
	c[1] = (e[0]);
	g_d[0] = (0);
	g_e[0] = (ar_j);
	a[0] = (g_d[0] + (g_ar_e + -4 * 2 + (-3) + 2) - 2);
	ar_d = (-2 - g_c[0] - g_e[1]);
	g_c[0] = (ar_d + ar_d);
	g_c[1] = (g_e[0] + g_ar_f);
	d[1] = (g_d[0]);
	g_ar_g = (-1);
	ar_c = ((d[1] - (ar_j) + -4 * c[0] + -2) - ar_a);
	g_e[1] = (e[0]);
	g_ar_i = (a[0]);
	ar_c = (0);
	e[0] = (3);
	d[0] = (((ar_e * 0 - g_ar_a)));
	ar_e = (g_a[1]);
	printf(" ",(para_i));
	g_ar_c = (g_ar_i - -1 * g_c[1] + g_d[0]);
	g_a[0] = (g_b[0]);
	a[0] = ((2));
	g_ar_e = (-5);
	g_e[0] = (a[0]);
	printf(" ",(ar_d));
	ar_i = (g_d[0] - ar_f);
	e[0] = (a[0] + 1);
	a[1] = (-1);
	ar_g = (g_a[1] * a[0]);
	para_h = (d[1]);
	a[0] = (para_f - 1 * a[1] + g_a[1]);
	g_e[0] = ((g_e[1] * g_a[0]) - e[0]);
	a[1] = ((-2));
	ar_a = (g_c[1] * g_d[0] - e[0]);
	d[0] = ((ar_f + 1));
	b[0] = (-4);
	g_a[0] = ((g_e[1] * e[0]) + (g_a[1]) * ar_c - ar_g);
	g_b[0] = (b[0] * -2 + 0 * ar_e);
	para_d = (g_ar_g);
	a[1] = (-5 - (e[1]));
	g_c[0] = (3);
	g_e[1] = (0 * (g_e[1] - g_a[1]));
	para_c = (ar_c * 4);
	ar_j = ((1 + g_e[1] * -3 + b[0] - g_c[0]));
	if ((g_ar_d) <= (d[1]))
	{
	}
	else
	{
	}
	para_c = (ar_c);
	g_ar_h = (-4);
	ar_c = (ar_d - 0);
	if ((d[0]) == (a[0] - -5 - -5 + g_b[0]))
	{
	}
	else
	{
	}
	g_d[0] = (b[0] * (a[1] - ar_g - -1));
	}
	printf("\nglo_vars:");
	printf(" ", g_ar_a);
	printf(" ", g_ar_b);
	printf(" ", g_ar_c);
	printf(" ", g_ar_d);
	printf(" ", g_ar_e);
	printf(" ", g_ar_f);
	printf(" ", g_ar_g);
	printf(" ", g_ar_h);
	printf(" ", g_ar_i);
	printf(" ", g_ar_j);
	printf("\n");
	printf("global_arrays:");
	printf(" ", g_a[0]);
	printf(" ", g_a[1]);
	printf(" ", g_b[0]);
	printf(" ", g_b[1]);
	printf(" ", g_c[0]);
	printf(" ", g_c[1]);
	printf(" ", g_d[0]);
	printf(" ", g_d[1]);
	printf(" ", g_e[0]);
	printf(" ", g_e[1]);
	printf("\n");
	printf("local_vars:");
	printf(" ", ar_a);
	printf(" ", ar_b);
	printf(" ", ar_c);
	printf(" ", ar_d);
	printf(" ", ar_e);
	printf(" ", ar_f);
	printf(" ", ar_g);
	printf(" ", ar_h);
	printf(" ", ar_i);
	printf(" ", ar_j);
	printf("\n");
	printf("local_arrays:");
	printf(" ", a[0]);
	printf(" ", a[1]);
	printf(" ", b[0]);
	printf(" ", b[1]);
	printf(" ", c[0]);
	printf(" ", c[1]);
	printf(" ", d[0]);
	printf(" ", d[1]);
	printf(" ", e[0]);
	printf(" ", e[1]);
	printf("\n");
	return (-5);
	}
	void main()
	{
	g_ar_a = -3;
	g_ar_b = 3;
	g_ar_c = 2;
	g_ar_d = 1;
	g_ar_e = 3;
	g_ar_f = -3;
	g_ar_g = -1;
	g_ar_h = -3;
	g_ar_i = 1;
	g_ar_j = -5;
	g_a[0] = -4;
	g_a[1] = -5;
	g_b[0] = 1;
	g_b[1] = -2;
	g_c[0] = -1;
	g_c[1] = 4;
	g_d[0] = 2;
	g_d[1] = -1;
	g_e[0] = 3;
	g_e[1] = 1;
	foo0(foo0(2, 1, -4, -1, -3, -5, -2, -3, 2, -3), -5, -1, -4, -4, 4, 4, -3, 4, -3);
	}


**结果**

     2 2 -2 -4 5 1 2 6
    glo_vars: -3 3 -8 1 -5 2 -1 -4 -12 -5
    global_arrays: -57 9 8 -2 3 4 92 -9 49 0
    local_vars: -3 2 6 6 9 -3 18 -1 3 -6
    local_arrays: 5 -6 -4 0 -9 -13 -2 0 3 1
     2 2 -1 -4 5 1 4 -80
    glo_vars: -3 3 82 1 -5 92 -1 -4 -12 -5
    global_arrays: -277 128 8 -2 3 94 1044 -9 32 0
    local_vars: -3 2 -80 -80 128 -3 256 -4 3 -6
    local_arrays: 133 -6 -4 0 -9 -7 -2 0 3 1

#### 1.2 测试程序2（正确）
**程序**

    int result;

	void foo{}

	void cal(int value)
	{
	result = result * 2 + value;
	}

	void cond(int a, int b)
	{
	if (a > 0)cal(0);else cal(1);
	if (a < 0)cal(0);else cal(1);
	if (a >= 0)cal(0);else cal(1);
	if (a <= 0)cal(0);else cal(1);
	if (a != 0)cal(0);else cal(1);
	if (a == 0)cal(0);else cal(1);
	if (a == b)cal(0);else cal(1);
	if (a != b)cal(0);else cal(1);
	if (a >= b)cal(0);else cal(1);
	if (a <= b)cal(0);else cal(1);
	if (a > b)cal(0);else cal(1);
	if (a < b)cal(0);else cal(1);
	if (a == a)cal(0);else cal(1);
	printf(" ", result);
	result = 0;
	}

	void main()
	{
	cond(0,1);
	cond(0,0);
	cond(1,0);
	cond(1,1);
	cond(-1,1);
	cond(-1,0);
	cond(1,-1);
	cond(0,-1);
	}
	
**结果**

     6484 6438 2762 2726 5332 5332 2762 6474
     
#### 1.3 测试程序3（正确）
**程序：**

	int get_index(int size, int row, int col) {
		return ((row-1)*size + (col-1));
	}

	void Zigzag {
		int a;
		int i;char temp;
		int tempi;
		char matrix[100];
		int row, col;
		printf ("Please enter the length of the matrix: ");
		scanf (a);
		while(a<=0){		printf ("It's too small, my friend! Please enter again: ");
			scanf (a);
		while (a >=10) {
			printf ("It's too small, my friend! Please enter again: ");
			scanf (a);
		}}
		i = 0;
		printf ("Got it! Please enter the matrix:\n");
		while (i<a*a){
			scanf (temp);
			matrix[i] = temp;
			i = i+1;
			if ((i)/a*a==i) {
				printf ("\n");
			}else;
		}
		printf ("ZIGZAG!\n");
		row = 1;
		col = 1;
		printf (matrix[get_index(a, row, col)]);
		while (row * col != a * a) {
			if (col == a) {
				row = row + 1;
			} else {
				col = col +1;
			}
			i=0;
			printf (matrix[get_index(a, row, col)]);
			tempi = col-row;
			while (i < tempi) {
				i = i+1;
				col = col -1;
				row = row + 1;
				printf (matrix[get_index(a, row, col)]);
			}
			
			
			if (row == a) {
				col = col + 1;
			} else {
				row = row +1;
			}
			i=0;
			printf (matrix[get_index(a, row, col)]);
			tempi = -col+row;
			while (i < tempi) {
				i = i+1;
				row = row -1;
				col = col + 1;
				printf (matrix[get_index(a, row, col)])
				;
			}
		}
	}

	void main()
	{
	zigzag;
	}

**结果**

输入：0[ENTER]3[ENTER]123123123

    Please enter the length of the matrix: 0
    It's too small, my friend! Please enter again: 3
    Got it! Please enter the matrix:
    123
    123
    123
    ZIGZAG!
    121123323

输入：4[ENTER]1234qwerasdfzxcv

    Please enter the length of the matrix: 4
    Got it! Please enter the matrix:
    1234
    qwer
    asdf
    zxcv
    ZIGZAG!
    12qaw34eszxdrfcv
    
#### 1.4 测试程序4（正确）
**程序**

	const int len = 100;

	int find_array[100];

	void init_array {
		int a;
		a = 0;
		while (a < len) {
			find_array[a] = a;
			a = a+1;
		}
	}

	void find(int begin, int end, int num) {
		int mid;
		
		if (begin == end) {
			if (find_array[begin] == num) {
				printf ("Found: ");
				printf (begin);
				printf ("\n");
			} else {
				printf ("[ 404 Not Found ]\n");
			}
			return;
		}else;
		mid = (begin + end) / 2;
		if (find_array[mid] < num) {
			find(mid+1, end, num);
		} else if (find_array[mid] > num) {
			find(begin, mid, num);
		} else if (find_array[mid] == num) {
			printf ("Found: ");
			printf (mid);
			printf ("\n");
		} else {
			printf ("You got a bug!");
		}
	}

	void main()
	{
	int num;
	init_array;
	while(1>=1){
					printf ("Please enter a number:");
					scanf (num);
	if(num == 12450) return;else;
					find(0,len-1, num);
	}}
	
**结果**

输入：4[ENTER]0[ENTER]99[ENTER]100[ENTER]12450[ENTER]

    Please enter a number:4
    Found: 4
    Please enter a number:0
    Found: 0
    Please enter a number:99
    Found: 99
    Please enter a number:100
    [ 404 Not Found ]
    Please enter a number:-1
    [ 404 Not Found ]
    Please enter a number:12450
    
#### 1.5 测试程序5（正确）
**程序**

    int a;

	void FluctuATions {
		int n;
		int a, b;
		int ra, rb;
		int sub;
		int max_sub;
		int i;
		printf ("Please enter the size of the array:");
		scanf (n);
		while (n <= 1) {
			printf ("Interesting.\n");
			printf ("Please enter the size of the array:");
			scanf (n);
		}
		a= 0;
		b = 0;
		max_sub = -1;
		i=0;
		while (-(-(-(-(i)))) < n) {
			scanf (a);
			sub = (a - b);
	printf("sub: ", sub);printf("\n");
			if (sub <= 0) sub = -(+sub);
			else;

			if (sub > max_sub) {

				ra =a;
				rb =b;
	max_sub = sub;
			}else;
	printf("BEST: ", max_sub);
	printf("\n");
			b=a;
	i=i+1;
		}
		printf ("The maximum fluctuation is ");
	printf(max_sub);
		printf (" from ");
		printf (ra);
		printf (" and ");
		printf (rb);
		printf ("\n");
	}

	void Fibonacci {
		int a,b,sum;  
	    int n,i;
	    a=1;
	    b=a;  
	    printf ("Please enter the length of the Fibonacci: ");
	    scanf (n);  
	    if (n <= 0 ) {
	    	printf ("It's meaningless!\n");
	    	return;
		}else;
	    printf (a);
	    printf ("\t");
	    if (n <= 1) {
	    	return;
		}else;
	    printf (b);
	    printf ("\t");
	    if (n <= 'c'-'a') {
	    	return;
		}else;
	    i=3;
	    while(i<=n){ 
	        sum=a+b;  
	        b=a;  
	        a=sum;  
	        printf (sum);
	        printf ("\t");
	        if (n / 10 * 10 == i+1) printf ("\n");else;
	        i = i+1;

	    }  
	    
	    return;  
	}

	char sort {
		int a[100];
		int size;   
	    int i, j, temp;   
	    
		printf ("Please enter the size of the array: "); 
		scanf (size);
		while(size >= '0' + 1 - '1' + 100) {
			printf ("Invalid size! Please enter the size again: ");
	    	scanf (size);
		}
		
		printf ("Got it! Now, please enter the ");
		printf (size);
		printf (" elements:\n");
		i = 0;
		while (i < size)  {
			scanf (temp);
			a[i] = temp;
	printf("Got ", a[i]);
	printf("\n");
			i = i + 1;
		}

		i = 0;
		while (i < size-1)
		{   
			j = 0;
		    while (j < size-1 - i){
		    	if (a[j] > a[j+1])   
			    {   
	printf("Exchange ", a[j]);
	printf(" ", a[j+1]);
	printf("\n");
			        temp = a[j];   
			        a[j] = a[j+1];   
			        a[j+1] = temp;   
			    }else;
			    j = j + 1;
		    }
		    i = i + 1;
		}   
	printf("[2]", a[2]);
	printf("\n");
		i = 0;
		printf ("The sorted array is:\n");
		while (i < size){
			i = i + 1;
	printf("[", i-1);
		    printf ("]",a[i-1]);  
			printf ("\t");
			if ((i+1) / 10 * 10 == i+1) {
				printf ("\n");
			}else;
		}

		return ('0');   
	}

	void select {
		int i;
		int num;
		while (1) {
			printf ("\n");
			printf ("======================\n");
			printf ("|   1. Sort          |\n");
			printf ("|   2. Fibonacci     |\n");
			printf ("|   3. FluctuaTions  |\n");
			printf ("|   0. Exit          |\n");
			printf ("======================\n");
			printf ("Please enter your choice(0-5):");
			scanf (i);
			switch (i/1*1) {
				case 0:  ;
				case 1: sort; 
				case 2: Fibonacci;
				case 3: FluctuATions; 
				default:
					printf ("Interesting.\n");
			}
			if (i==0) {
				printf ("Bye");
				return;
			}else;
		}
	}

	void main() {
		select;
	}

**结果**

输入：

1[ENTER] // 排序

4[ENTER]6[ENTER]7[ENTER]2[ENTER]3[ENTER]7[ENTER]6[ENTER]3[ENTER]4[ENTER]5[ENTER]

2[ENTER] // 斐波那契

0[ENTER]

2[ENTER] // 斐波那契

10[ENTER]

1[ENTER] // 排序

0[ENTER]

3[ENTER] // 波动

5[ENTER]

0[ENTER]4[ENTER]7[ENTER]-1[ENTER]4[ENTER]

4[ENTER] // 错误请求

-1[ENTER] // 错误请求

0[ENTER] // 退出

    ======================
	|   1. Sort          |
	|   2. Fibonacci     |
	|   3. FluctuaTions  |
	|   0. Exit          |
	======================
	Please enter your choice(0-5):1
	Please enter the size of the array: 10
	Got it! Now, please enter the 10 elements:
	4
	Got 4
	6
	Got 6
	7
	Got 7
	2
	Got 2
	3
	Got 3
	7
	Got 7
	6
	Got 6
	3
	Got 3
	4
	Got 4
	5
	Got 5
	Exchange 7 2
	Exchange 7 3
	Exchange 7 6
	Exchange 7 3
	Exchange 7 4
	Exchange 7 5
	Exchange 6 2
	Exchange 6 3
	Exchange 7 6
	Exchange 7 3
	Exchange 7 4
	Exchange 7 5
	Exchange 4 2
	Exchange 4 3
	Exchange 6 3
	Exchange 6 4
	Exchange 6 5
	Exchange 6 3
	Exchange 6 4
	Exchange 6 5
	Exchange 4 3
	[2]3
	The sorted array is:
	[0]2	[1]3	[2]3	[3]4	[4]4	[5]5	[6]6	[7]6	[8]7	
	[9]7	
	======================
	|   1. Sort          |
	|   2. Fibonacci     |
	|   3. FluctuaTions  |
	|   0. Exit          |
	======================
	Please enter your choice(0-5):2
	Please enter the length of the Fibonacci: 0
	It's meaningless!

	======================
	|   1. Sort          |
	|   2. Fibonacci     |
	|   3. FluctuaTions  |
	|   0. Exit          |
	======================
	Please enter your choice(0-5):2
	Please enter the length of the Fibonacci: 10
	1	1	2	3	5	8	13	21	34	
	55	
	======================
	|   1. Sort          |
	|   2. Fibonacci     |
	|   3. FluctuaTions  |
	|   0. Exit          |
	======================
	Please enter your choice(0-5):1
	Please enter the size of the array: 0
	Got it! Now, please enter the 0 elements:
	[2]55
	The sorted array is:

	======================
	|   1. Sort          |
	|   2. Fibonacci     |
	|   3. FluctuaTions  |
	|   0. Exit          |
	======================
	Please enter your choice(0-5):3
	Please enter the size of the array:5
	0
	sub: 0
	BEST: 0
	4
	sub: 4
	BEST: 4
	7
	sub: 3
	BEST: 4
	-1
	sub: -8
	BEST: 8
	4
	sub: 5
	BEST: 8
	The maximum fluctuation is 8 from -1 and 7

	======================
	|   1. Sort          |
	|   2. Fibonacci     |
	|   3. FluctuaTions  |
	|   0. Exit          |
	======================
	Please enter your choice(0-5):4
	Interesting.

	======================
	|   1. Sort          |
	|   2. Fibonacci     |
	|   3. FluctuaTions  |
	|   0. Exit          |
	======================
	Please enter your choice(0-5):-1
	Interesting.

	======================
	|   1. Sort          |
	|   2. Fibonacci     |
	|   3. FluctuaTions  |
	|   0. Exit          |
	======================
	Please enter your choice(0-5):0
	Bye
	
#### 1.6 测试程序6（错误）
**程序**

	void foo1 {}

	void foo1
	{
		int a;
		return (5);
		a = a + 1;
		a = a + 1;
	}

	int foo2
	{
		const int foo1 = 5;
		int a;
		a = a + foo1;
	}

	int foo3
	{
		int foo2;
		int foo3;
		int a;
		a = 3;
		return;
	}

	int foo4(int foo4, int foo3)
	{

	}

	void main()
	{
	foo4(3, 'a');
	return;
	}
	
**结果**

    === CONST BEGIN ===
    === VAR BEGIN ===
    === FUNC BEGIN ===
    [ERROR] redefinition of 'foo1' in 4
    [ERROR] expected type 'void', got 'int' in 6
    [ERROR] conflicting declaration with function name in 13
    [ERROR] void value not ignored as it ought to be in 15
    [ERROR] function returning 'int' without a return-statement in 16
    [ERROR] conflicting declaration with function name in 20
    [ERROR] conflicting declaration with function name in 21
    [ERROR] return-statement with no value, in function returning 'int' in 24
    [ERROR] conflicting declaration with function name in 27
    [ERROR] conflicting declaration with function name in 27
    [ERROR] function returning 'int' without a return-statement in 30
    [ERROR] parameters to function 'foo4' do not match in 34
    
#### 1.7 测试程序7（错误）
**程序**

	void expr()
	{
		const int con = 7;
		int a[100];
		int b;
		con = 5;
		4 = 1;
		a = 5;
		a[100] = 0;
		a[-1] = 0;
		a[b] = 0;
		a[50 * 2] = 0;
		b = b / 0;
		printf("ERROR: ", 0 / 0);
		b = 6 5;
		c = a;
	}

	void main()
	{
		int b;
		b = b / 0;
	}

**结果**

    === CONST BEGIN ===
    === VAR BEGIN ===
    === FUNC BEGIN ===
    [ERROR] invalid parameter type RPAR in 2
    [ERROR] got RPAR expected IDENT in 2
    [ERROR] assignment of non-var 'con' in 7
    [ERROR] unexpected token 'INTCON' in the beginning of the statement in 8
    [ERROR] unexpected token 'ASS' in the beginning of the statement in 8
    [ERROR] unexpected token 'INTCON' in the beginning of the statement in 8
    [ERROR] array 'a' without an index in 9
    [ERROR] index of array 'a[]' out of range in 10
    [ERROR] index of array 'a[]' out of range in 11
    [ERROR] index of array 'a[]' out of range in 13
    [ERROR] division by zero in 14
    [ERROR] division by zero in 15
    [ERROR] got INTCON expected SEMI in 16
    [ERROR] unexpected token 'INTCON' in the beginning of the statement in 16
    [ERROR] unexpected token 'c' in 17
    [ERROR] unexpected token 'ASS' in the beginning of the statement in 17
    [ERROR] array 'a' without an index in 17
    [ERROR] meaningless variable 'a' in 17
    [ERROR] division by zero in 23

#### 1.8 测试程序7（错误）
**程序**

    const int a = 5;
	const int a;
	int b;
	const int c = 6;

	void foo {
		int s;
		int a = 5;
		const int a = 6;
	}

	const int e  =5;
	int d;

	void main()
	{
		int a;
		printf("BAKABAKABAKA!!")
		a = 5;
		int b;
	}

	void foo2 {}

**结果**

    === CONST BEGIN ===
    [ERROR] got SEMI expected ASS in 2
    [ERROR] got SEMI expected INTCON in 2
    [ERROR] redefinition of 'a' in 2
    === VAR BEGIN ===
    [ERROR] const defination after var in 4
    === FUNC BEGIN ===
    [ERROR] got ASS expected SEMI in 8
    [ERROR] unexpected token 'ASS' in the beginning of the statement in 8
    [ERROR] unexpected token 'INTCON' in the beginning of the statement in 8
    [ERROR] unexpected token 'CONSTSY' in the beginning of the statement in 9
    [ERROR] unexpected token 'INTSY' in the beginning of the statement in 9
    [ERROR] const defination after function in 12
    [ERROR] var defination after function in 13
    [ERROR] got IDENT expected SEMI in 19
    [ERROR] unexpected token 'INTSY' in the beginning of the statement in 20
    [ERROR] meaningless variable 'b' in 20
    [ERROR] something behind 'main' in 23

#### 1.9 测试程序7（错误）
**程序**

    int foo2 { return (1); }
	char foo3 { return ('0'); }

	int cal
	{
		int a;
		char b;
		a = 007;
		a = 6 * 007;
		a = b;
		b = a;
		b = foo2;
		a = foo3;
		b = '&';
		printf("	");
		b = '';
		b = 'WTMSB';
		printf("");
	}

	int b;
	const int c;

**结果**

    === CONST BEGIN ===
    === VAR BEGIN ===
    === FUNC BEGIN ===
    [ERROR] unexpected leading zero in 8
    [ERROR] unexpected leading zero in 9
    [ERROR] cannot convert 'int' to 'char' in 11
    [ERROR] cannot convert 'int' to 'char' in 12
    [ERROR] invalid char in 14
    [ERROR] invalid char in string in 15
    [ERROR] empty char in 16
    [ERROR] multiple chars in 17
    [ERROR] function returning 'int' without a return-statement in 19
    [ERROR] var defination after function in 21
    [ERROR] const defination after function in 22
    [ERROR] unfinished program in 22

#### 1.10 测试程序7（错误）
**程序**

    const char a = 'b' ,;
	int a, ;

	void foo(int, int a) {}

	void main
	{
		const;
		int;
		int a,;
		a = 5;
		printf();
		scanf();
		foo(2, );

	}

	void main() {}

**结果**

    === CONST BEGIN ===
    [ERROR] got SEMI expected IDENT in 1
    === VAR BEGIN ===
    [ERROR] redefinition of 'a' in 2
    [ERROR] got SEMI expected IDENT in 2
    === FUNC BEGIN ===
    [ERROR] got COMMA expected IDENT in 4
    [ERROR] got LBRACE expected LPAR in 7
    [ERROR] got LBRACE expected RPAR in 7
    [ERROR] unexpected const type SEMI in 8
    [ERROR] got SEMI expected IDENT in 9
    [ERROR] got SEMI expected IDENT in 10
    [ERROR] unexpected token 'RPAR' in factor in 12
    [ERROR] got RPAR expected IDENT in 13
    [ERROR] got SEMI expected IDENT in 13
    [ERROR] got SEMI expected RPAR in 13
    [ERROR] unexpected token 'RPAR' in factor in 14
    [ERROR] parameters to function 'foo' do not match in 14
    [ERROR] something behind 'main' in 18

### 2. 测试结果分析
#### 2.1测试程序1（正确）

本程序为自动生成程序，用于测试表达式计算，包括常量变量夹杂的情况、数组和普通变量夹杂的情况、全局和局部夹杂的情况，以及函数调用传参与返回。类似的测试程序还有很多，这里只是举一例

#### 2.2测试程序2（正确）
本程序用于测试比较运算是否正确，包括常数比较优化，常数和变量的比较、变量和变量的比较，最后输出的数为所有分支合成的二进制转十进制数，具有唯一性

#### 2.3测试程序3（正确）
本程序为Z字形输出矩阵，本质是一个二维数组，用来测试数组正确性，还包括简单的常数计算以及循环判断

#### 2.4测试程序4（正确）
本程序为二分法搜索，给定一个0~99的数字，返回相同的数字代表正确（并不是将原数字直接输出），找不到返回“[404 Not Found]”，输入12450跳出循环。

#### 2.5测试程序5（正确）
本程序为三个小程序的集合，用以测试switch的正确性。三个小程序分别为排序、斐波那契数列和最大相邻波动值，涉及表达式计算、循环、数组运算等等，输入0退出，输入不同于1、2、3的数字会提示“Interesting”用以检测default的正确性。

#### 2.6测试程序6（错误）
本程序测试函数调用相关错误

 - 第4行函数头末尾foo1定义重复
 - 后面多次出现局部变量、常量名与函数名冲突的情况
 - 第6行void函数返回了int，需要报错
 - 第15行foo1为void类型函数，无返回值，不能出现在表达式中
 - 第16、30行有返回值函数末尾没有return语句
 - 第24行return语句没有返回数值，报错
 - 第34行参数类型不符
 
#### 2.7测试程序7（错误）
本程序测试表达式运算

 - 根据while文法要求，无参函数不能有空括号，2行报错
 - 7行常量赋值
 - 8行左边不能为整数
 - 9行数组没有指定下标
 - 10、11、13行下标越界
 - 14、15、23行除数为0
 - 16行数字间出现空格导致语法错误
 - 17行c未定义导致错误
 
#### 2.8测试程序8（错误）
本程序测试函数、常量、变量声明

 - 2行没有初始化常量
 - 4行、9行在初始化变量之后又初始化常量
 - 12行和13行分别在初始化函数之后又初始化变量/常量
 - 8行不允许初始化变量
 - 18行缺少分号，19行开头并非分号，报错
 - 20行定义变量，报错
 - main函数结束之后还定义其它函数，不符合文法，报错
  
#### 2.9测试程序9（错误）
本程序主要测试常数合法性

 - 8、9行有前置零
 - 11、12行不允许int赋值给char
 - 14、15行不允许出现非法字符
 - 16行不允许出现空字符（根据文法，18行空字符串合法）
 - 17行不允许出现多字符型字符常数
 - 21、22行定义位置错误
 - 缺少main函数，程序不完整
   
#### 2.10测试程序10（错误）
本程序主要测试缺少成分的情况

 - 1、2、10行逗号后面缺少标识符
 - 2、9行类型后面缺少标识符
 - 8行只有一个const
 - 6行根据文法要求，main函数后面必须跟空的括号，报错
 - 12、13行空的printf语句和scanf语句
 - 14行调用函数参数不完全
 - 18行main函数后面还有一个main，实际上main函数后面不允许跟任何语句，无论是不是第二个main函数
 
## 五．总结感想
不出意外的话这应该是至今为止完成的最大的个人项目了，不算头文件与删除的废代码，最终长度大概在6k~7k行，还是很有成就感的（虽然很臃肿hhh）。这一个月下来，差不多理解了编译器工作的大致流程，同时也让一个之前没怎么接触过C++的人能够掌握一些常用的技巧，令我挺满意的。
 
主要说一些不足之处，前面也说了代码很长，自然就暴露出了代码管理的一些问题，比如面向对象思路不是很明确，是面向过程和面向对象夹杂的形式，可读性特别差，这一点在后期debug的时候体现得淋漓尽致，连自己都忘了DAG图是怎么写的了……一个特别小的例子就是判断集合中是否有某元素，这个之前一直是一个集合分配一个函数，但其实可以用模板直接一个函数搞定的，这样就显得清晰很多。最后看来很多函数功能都差不多，代码重复率特别高，写起来和读起来都很痛苦。

还有函数名、类名取得也不好，什么Block、temp、Node名字随便用，到后面自己也不知道为什么要取这么些鬼名字，太模糊了……总体来讲还是代码缺乏一定的结构性，各个函数关系比较散，这是设计不充分的体现，导致在写代码的时候想到一个函数写一个函数，最终也只是一盘散沙，立体不起来。感觉需要读一些相关书籍，提高代码管理的技能。

总体来看虽然写起来很费劲，但其实也只是完成了一个特别特别low的编译器而已，写C++的时候就在想，C++这么复杂的文法，背后的编译器得复杂成啥样啊，出现bug得de多半天啊……这样一想就感觉自己做得工作太微小了，还有太多知识需要学习一个。