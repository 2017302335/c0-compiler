
# 如何有效拆分课设的工作——C0编译器全流程解析

　　*其实一开始在阅读pascal代码的时候，我的心情是无比复杂的，虽然不熟悉pascal语言是一方面，但更主要的是搞不清各个函数的功能和联系，也不清楚一个合格的编译器都由哪几个部分组成，总觉得书本上是一套，实际过程中又是一套，读完之后不仅没对编译器实现有着多少帮助，反而加大了内心的压力，不禁怀疑：这学期结束的时候我究竟还能不能活着见到我实现的编译器呢？*

　　*现如今距离阅读pascal代码已经两个月过去了，现在我成功实现了编译器，并且还做了书上描述的大部分优化。回顾这一学期的开发历程，编译课设给我的感觉像是一个纸老虎，虽然来势汹汹，但其实并没有什么特别刁钻的地方，虽然踩过很多坑，但也完全不足以致命，充其量也只是工作量的问题（到了期末很多课都结课了，大作业堆在一起很难受）。现在我简单回顾一下这期间的经历，总结一下如何才能完成编译技术的课程设计。*

　　*另外我是使用C++编写的编译器，而不是C语言，因为STL里面一些容器类比较适合做符号表一类的数据结构，不过还是看个人喜好啦~*

------

　　首先要明白编译器的结构究竟是什么？我们可以把一个编译器看做一个庞然大物，也可以将其看作为若干杂的小集团，一旦将编译器拆分成若干个小目标，我们就可以很清楚地描述出实现的流程和计划。书上对编译器组成的描述是：**词法分析**、**语法分析**、**语义分析**、**代码生成**、**代码优化**、**出错处理**和**符号表处理**，这七个部分构成了一个完整的编译器。但我个人感觉这个划分不太适合课设的设计，实际上，课设的审核共分为如下几个阶段：**编译器源代码阅读与分析**（与编译器编写无关）、**文法解读作业**（这个也不是实际的编码）、**词法分析和设计文档**（对应书上的词法分析）、**语法分析程序**（对应书上的语法分析和语义分析）、**代码生成程序**（代码生成，其中涉及到中间代码的生成和目标代码的生成）、**目标代码执行**（自愿，但基本上大家都做了，实际上工作量并不大）、**测试程序考核**（一、二、三、四，其中后两次需要优化）。

　　可能是编译器不同组件之间的工作量很难统一，每次考核前要写的代码数量都相差比较大，比如词法分析是一周时间写完，而代码生成也是一周写完，后者设计中间代码和目标代码，而且设计不好很有可能会影响后面几周的编码体验，难度明显比前者要大很多。而在这之后就清闲了一些，直到前两次测试考核都不需要涉及优化部分。我个人的建议是，**不要太在意考核的时间点，按照自己的节奏来最为合适**。

　　首先大约制定一下要做哪些工作，尽可能保证这些工作的独立性，不要因为其它工作的需要去变更其它模块的代码。我是如下划分的：


### 工作一：词法分析和错误处理接口

　　之所以把错误处理接口和词法分析放在一起，是因为在词法分析过程中已经涉及到一些文法错误了，为了尽量不在旧代码上打补丁，这里最好一步到位，同时因为写词法分析的时候思路可能比之后读代码更佳清晰，所以很容易在写词法分析过程中考虑到更多的可能出错的敌法，不会被忽略。

　　我的处理方法是做一个error(string info)函数，info是传进来的错误信息，error会将错误信息后面加上行号，然后输出到命令行。初次之外还可以在error这里加一些debug专用的功能，比如退出程序以及输出调试信息等等，比直接在代码从散布一堆cout要好很多。

### 工作二：语法语义分析、符号表管理外加中间代码生成

　　首先必须要承认的是，这部分工作要比上面多一些，因此可以给这部分工作分配多一些的时间。感觉这部分工作很像是在处理一个翻译文法，读到一部分内容之后执行一部分操作，虽然实际编码中并没有做把原文法改写成翻译文法的工作，但感觉尝试做一做可能会使思路更清晰。

　　这里我们只需要利用到词法分析阶段的getsym()函数来获取一个符号，不必关心词法分析阶段的其它事情，而且要相信传回来的符号一定是正确的。

#### 寄存器的分配

　　在读取符号的同时，我们还需要将读到的变量、常量、函数名扔到符号表里去。这部分比书上的要简单的多，因为C0文法不支持函数的嵌套定义，所以实际上只需要考虑全局变量和函数内局部变量两层就可以，我的设计是建了三个大表，分别存储全局变量表、全局常量表和函数表，其中函数表内部又有两个小表，用来存储局部变量和局部常量，这样一来符号管理就很清晰了，无论是取全局变量还是局部变量都很方便。

#### 中间代码生成

　　另外在这一步中，需要在适当地方调用中间代码生成的接口。这里我不建议在语法语义分析代码中穿插文件写入语句，而是用适当的接口封装一下，以函数调用的形式控制中间代码的输出，这样在后期调试的时候可以尽可能减少对语法语义部分的改动。

　　另外，在这一阶段要尽可能考虑中间代码的灵活性，因为中间代码本质上是我们自己设计的一种文法，不要引入一些二义性等问题给自己挖坑。

　　这里举个例子，书上全部的临时变量都是用t0、t1去表示的，那么假如源代码中出现了t0这个变量该怎么办呢？怎么区分是局部变量还是临时变量呢？我是将所有临时变量用#0、#1去表示，因为#这个字符不可能出现在变量中，这样凡是带#的都是临时变量，判断起来就十分方便。另外中间代码中并不全都是赋值语句，还有很多诸如分支跳转、函数调用和声明、printf和scanf这些特殊的指令，这里我对所有非变量的符号前面加上@，比如@printf，因为@这个符号在变量中也没有，这样就给自己提供了很多方便。同时中间代码设计一定要尽可能提供较多的信息，比如printf后面可以加上输出的类型，让目标代码只通过读取中间代码和符号表就能够翻译成目标代码。

### 工作三：目标代码生成：寄存器分配和存储空间分配

#### 寄存器的分配

　　由于寄存器分配相关工作可以放到优化部分去解决，因此即便在这里简单分配了寄存器，到头来还是要重写寄存器分配的逻辑部分。我的舍友们在这一部分一开始都是暴力分配一两个寄存器，这样减少了很多不必要的工作，而我在这一部分已经实现了轮转法分配寄存器，在优化的时候一点忙都没帮上，反而在之前调试的时候出了一堆bug（过早的优化是一切罪恶的根源，呵呵）。

　　不过即便采用最简单的寄存器分配方式，到优化的时候也免不了要修改这一部分的代码，为了减少修改代码的机会，这里可以假设已经在优化阶段中分配好了全局寄存器，即一部分寄存器已经被占用了（虽然实际上并没有）。当然，我们的变量数量完全可以达到几十或几百，而留给我们使用的寄存器也无非就那么32个，想也知道一个变量占用一个寄存器是不现实的，因此假设在优化过程中我们已经实现了寄存器分配相关的工作，也不可能让每一个寄存器都分配出去，肯定要留下一部分寄存器让其他的变量去抢，因此我们就得到了一个抽象出来的问题：

　　**给定若干个寄存器，给定若干个变量（无论局部、临时还是全局，无论变量还是数组），怎么合理地设置一种寄存器替换策略？**

　　这时候就可以采用上面所说的轮转法等等分配寄存器的策略了，只不过我在设计这种策略的时候将寄存器定死在某一数量，而且强制让所有变量一起去抢，设计得很僵硬，要在此基础上增加灵活性很有可能增加新的bug，索性就重构了。

#### 合理的存储分配

　　不可能全部的变量都存储在寄存器中，和内存作交换是必不可少的。而变量的存储位置自然也不是绝对的，究竟存在哪一个具体的地址在编译的过程中只有上帝知道，但是我们可以知道的是每一个变量地址相对于当前函数存储位置基地址的偏移量，这个基地址我是用fp寄存器来存储，每调用一次函数fp指针内的值就会有所改变。我们只需要考虑两个问题：

1. 怎么确定调用函数后fp指针的值？
2. 怎么确定各个变量相对于fp的位置？

　　这两个问题都很好解决。首先确定一下我们能在编译过程中知道什么，比如所有变量的类型和所有变量的个数就是我们知道的，有了这两个就可以计算出函数存储空间的大小，我们只要把fp指向的内存地址放到这外面就不会引发事故。如果想追求完美，可以确定一下调用新函数的时刻旧函数究竟用了多少空间，我们只要把fp放在已经使用的空间后面，而不必放到计划使用的空间后面，只要确保旧函数的变量值不会被覆盖就可以了。

　　而局部变量可以根据声明的顺序分配内存，临时变量可以根据号码计算偏移量，不算太难。

### 工作四：公共子表达式的删除

　　个人认为这是所有工作中最难的部分，而主要难在如何优化得更彻底。书上的描述的算法是在一个比较理想的情况下，没有printf和scanf，没有函数调用，没有return，没有全局变量和局部变量的区分……而这些都是在实际中会遇到的情况。如果只是稍微优化一下，不想让DAG图扩充得很大，自然不用考虑这么多，只要在遇到这些奇怪的语句之前就将DAG图情况转变成代码就好。但假如想尽可能提高优化的效率，就要让DAG跨越这些奇怪的语句，变得越来越丰富。

　　我的策略是：**选择性输出，保留现有图**。

　　首先理解一下这几个语句的本质，printf和函数调用（接收返回值）本质上是“用”到了某变量，等同于在等号右边；而scanf本质上是“定义”了某变量，等同于在等号左边。这样就找到了这几个语句的共性。除此之外，**不必要的语句不输出**。一些临时变量如果没被后面用到就不要输出，我的办法是不选取整个DAG图的父节点，而是直接找到需要用到的那个结点（哪怕它是有父节点的，但是我们不管它），以它为父节点输出后面的语句，之后再做上标记，表示“这个结点我们已经输出了，不要重复输出”。

### 工作五：数据流分析与寄存器分配

　　个人认为这一部分主要难在数据结构上，比如可能出现同一变量可以分配不同寄存器的情况，需要使用适当方法将它们区分。最终我们要得到一张表，给定函数名、标签名，就可以得到这一基本块的寄存器分配情况。

　　我认为比较需要注意的是冲突的定义，书上似乎只考虑了基本块入口的冲突情况，而我是同时考虑了入口和出口，虽然我并不确定自己的设计是否合适……其实这部分算法和书上描述的已经基本差不多了，照着书上写得一步一步做完全没有问题，这里就不详细说了。

　　对于之前提到的同一变量分配不同寄存器的区分问题，我是给每个基本块中的变量都分配了一个结点，在初始化的时候，不同基本块的变量占有不同的结点，之后假如两个它们在数据流分析的时候相遇了，就将两个结点合并，如果最终一直都没有合并，就表示它们是要分配不同寄存器的。

### *后记*

　　总得来说，这一次收获还是不小的，只是恨自己太缺乏计划性，导致代码很臃肿，模块之间耦合性太强。实际上计划工作应该在第一次写设计文档的时候就做好（词法分析阶段），但那时候对编译器还没有整体的认知，很难计划出什么。这一篇总结一是申优（逃），二是总结一下这两个月的思路，反省一下哪里值得改进，三是如果有机会的话，给学弟学妹们提供一些微小的借鉴，也算是值得啦。

1/14/2018 12:31:07 AM 